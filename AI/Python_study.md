-hw1

range 함수의 시작지점 끝지점을 지정할 수 있다는 것과
for + append 를 사용해서 리스트 뒤에 값을 넣어줄 수 있다는 점을 체크할 것 
리스트 슬라이싱에서 리스트 속 숫자와 인덱스 값이 헷갈릴 수 있으니 주의



-필기

animal에 animals 속 변수가 있는 만큼 돌아라






인덱스 정보까지 알 수 있음




짝수만 나오게 (홀수라면 if  x % 2 ==1)

사전 key : value 의 형태


{}를 이용해서 생성, d[key] = value 
Print (key in d) = true or false //key가 d안에 있나요?
d[key] = value //새로운 key 와 value 추가
d.get( key , anything) // key가 있으면 value 없으면 anything 
del d[key] // key값을 d에서 지운다


밑 칸 처럼 포문 사용



SETS (그렇게 많이 쓰지 않음)

List 와의 차이점 ?
List는 순서가 중요함 
집합은 순서 중요 X 개념 X 중복되는 게 있으면 안된다




순서대로 출력되지 않는다 랜덤




TUPLES (순서가 있음)



FUNCTIONS



CLASSES



NUMPY / matrix 연산 모아놓은 거 
Vector 도 matrix 
같은 사이즈(모양)의 행렬끼리 연산 가능
N * K  K * M 

SCIPY / 

내적 : 두 개의 백터가 얼마나 비슷한지 알게 해주는 스칼라 값 
비슷하다 -> 방향과 크기가 얼마나 비슷한지

행렬 곱 곱 .. 벡터의 크기와 방향… 
크기를 맞춰서 정규화 해줘야 함 

>>>

List 배열과 링크드리스트를 합쳐놓은 특성 
숫자를 연산하려고 하니까 뭔가 불편 

✨ Inner product 
벡터 벡터 = 스칼라
벡터는 방향이 중요하지 !!! 크기는 중요하긴 한데 크게 중요하지는 않음
각도만 가지고 유사도를 알 수 있다
v * vt = [ 1, 5 ] [ 2
                           7 ] <- v * v 로 나타내지 않는 이유
✨ Outer product 
+ - * / 


수학 
방정식 ax + bx + cx = 0
함수 y = ax^2 + bx

1차 방정식을 벡터의 내곱으로 표현할 수 있다 




다들 np라고 쓰니까 np라고 쓰세요 


Rank 란 1차원인지 2차원인지 뜻하는 것 

TUPLE 2개 이상 있어야 함 
Shape : (2*3) 같은 행렬 사이즈 알려주는 함수

초기화 



np.eye(2) 단위행렬 만드는 함수 n * n 이어야 하니까 숫자 하나만 넣어도 됨

Random 0~1 중에서 나옴 


Array indexing
Slicing 



같은 데이터를 가지고 있기 때문에 b를 바꿔도 a에서 값이 바뀐다 !!!  ✨






[1,4,5]  why? 0,0 1,1 2,0 이기 때문이다 ~~~~





 a[[0,1,2,3],[0,2,0,1]] 
0,0  1,2  2,0  3,1




이런 연산도 가능

Boolean 연산도 가능함



Array math






곱하기 위해서 모양 바꾸는거 대응되는 요소

Broadcasting

행렬의 곱을 하려고 하면 n*m m*k 로 해야함
문제 ? 모양이 맞아야 곱이 됨
2*3 * 1*2 로 준걸 1*2 => 3*2로 바꿔야함  카피해서 행렬을 만듦

1 2 3        1 2          뭘 카피해야할지 모르는 상황이면 브로드캐스팅이 안됨 
4 5 6   *   1 2
                1 2


